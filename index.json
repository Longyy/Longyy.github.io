[{"categories":["Go系列"],"content":"1.前言 说起项目依赖管理工具大家一点都不陌生，像Java的Maven、Python的Pip、Php的Composer、Nodejs的Npm这些工具大家都耳熟能详。项目依赖管理工具是项目的基石之一，它的好坏往往深刻影响着项目开发运行的效率、稳定性、扩展性、安全性等重要指标。今天我们来聊一聊Golang的包管理工具Go mod. 在此之前，我们必须要熟悉两个重要的环境变量GOROOT与GOPATH. GOROOT 指示GO的安装位置，其中有GO的原生类库(SDK)，在编译GO时需要用到； GOPATH 指示项目代码和依赖包的位置；必须设置，但是可以随项目不同而重新设置；GOPATH下有三个目录： src 存放项目代码或依赖包源码； bin 存放由go install 或 go get 编译产生的二进制文件，为方便执行，最好将$GOPATH/bin 加入PATH路径； pkg 存放预编译产生的文件用于加速编译过程，通常我们不需要关心这个目录，它由GO自动管理； $ echo $GOPATH /Users/longyongyu/Development/go/workspace $ tree ./pkg/darwin_amd64 pkg/darwin_amd64 └── github.com ├── gogo │ └── protobuf │ ├── gogoproto.a │ ├── jsonpb.a │ └── proto.a └── golang └── protobuf └── proto.a $ ls -l ./bin total 533296 -rwxr-xr-x 1 longyongyu staff 8961980 10 21 11:59 db2struct -rwxr-xr-x 1 longyongyu staff 18795324 9 9 18:47 dlv -rwxr-xr-x 1 longyongyu staff 5871480 6 22 2020 goimports -rwxr-xr-x 1 longyongyu staff 6315432 6 22 2020 golint $ tree -L 2 ./src ├── go.uber.org │ ├── atomic │ ├── multierr │ └── zap ├── golang.org │ └── x ├── google.golang.org │ ├── genproto │ ├── grpc │ └── protobuf 查看当前项目的GO环境变量可以用go env $ go env GO111MODULE=\"on\" GOARCH=\"amd64\" GOBIN=\"\" GOCACHE=\"/Users/longyongyu/Library/Caches/go-build\" GOENV=\"/Users/longyongyu/Library/Application Support/go/env\" GOEXE=\"\" GOFLAGS=\"\" GOHOSTARCH=\"amd64\" GOHOSTOS=\"darwin\" GOINSECURE=\"\" GONOPROXY=\"xxx\" //去掉了敏感信息 GONOSUMDB=\"yyy\" //去掉了敏感信息 GOOS=\"darwin\" GOPATH=\"/Users/longyongyu/Development/go/workspace\" GOPRIVATE=\"zzz\" //去掉了敏感信息 GOPROXY=\"https://goproxy.cn\" GOROOT=\"/usr/local/go\" GOSUMDB=\"sum.golang.org\" GOTMPDIR=\"\" GOTOOLDIR=\"/usr/local/go/pkg/tool/darwin_amd64\" GCCGO=\"gccgo\" AR=\"ar\" CC=\"clang\" CXX=\"clang++\" CGO_ENABLED=\"1\" GOMOD=\"/dev/null\" CGO_CFLAGS=\"-g -O2\" CGO_CPPFLAGS=\"\" CGO_CXXFLAGS=\"-g -O2\" CGO_FFLAGS=\"-g -O2\" CGO_LDFLAGS=\"-g -O2\" PKG_CONFIG=\"pkg-config\" GOGCCFLAGS=\"-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0\\ -fdebug-prefix-map=/var/folders/dg/b4mzy9tx1ln1y7bkblz5lvsc0000gn/T/go-build462069466=/tmp/go-build\\ -gno-record-gcc-switches -fno-common\" 要更改GO环境变量可以用go env -w 命令，如： $ go env -w GOPROXY=test.com ","date":"2020/12/21","objectID":"/go-mod/:1:0","tags":[],"title":"Go mod原理一次讲透","uri":"/go-mod/"},{"categories":["Go系列"],"content":"2.Go依赖管理工具发展 Go的包管理工具几经调整，从最开始的gopath、govender到后来的go mod, 以致go mod成为自v1.13以后的事实标准，都反映出了大家对于一款好用的包管理工具的急切渴望。下面列出其主要工具的发展过程： V1.5之前，使用原生的gopath 进行包管理，要求项目源码与依赖包必须位于$GOPATH/src目录下；最大的问题，不能进行依赖包的多版本管理； V1.5, 引入govendor ，GO环境变量需设置GO15VENDOREXPERIMENT=1 在项目根目录下自动生成vendor目录并存放依赖包, GO在编译时会优先去vendor目录查询依赖；vendor对依赖包进行了分类： 状态 缩写 含义 +local l 本地包，即项目自身的包组织 +external e 外部包，即被 $GOPATH 管理，但不在 vendor 目录下 +vendor v 已被 govendor 管理，即在 vendor 目录下 +std s 标准库中的包 +unused u 未使用的包，即包在 vendor 目录下，但项目并没有用到 +missing m 代码引用了依赖包，但该包并没有找到 +program p 主程序包，意味着可以编译为执行文件 +outside 外部包和缺失的包 +all 所有的包 v1.9, 引入godep , 在govendor的基础上，记录了依赖包的版本信息存放于项目根目录的Godep目录下，需要与vendor目录一起提交至代码库；godep常用命令： go get -u -v github.com/tools/godep 安装godep； go get github.com/globalsign/mgo 下载并安装依赖包； import github.com/globalsign/mgo 引用依赖包； godep go build main.go 编译项目； godep save 更新Godeps/Godeps.json文件； godep restore 拉取Godeps/Godeps.json文件定义的依赖包至$GOPATH/src目录下； Kubernetes早期版本就是用godep管理依赖的。 v1.11, 社区推出了go mod 方案，目前已成为GO的主流包管理工具，且大部分GO项目已支持go mod. go mod具有几个特点： 项目代码摆脱了对$GOPATH/src 目录的依赖，在此之外的任何目录都可以使用go mod; Goproxy代理协议，可以使用代理拉取依赖； go mod的Tag必须遵循语义化版本控制, 如果没有则将忽略Tag, 转而根据commit时间与commit hash值生成一个临时的版本号； 模块缓存。同一Module版本的数据只缓存一份，所有其他模块共享，目前所有模块版本数据均缓存在$GOPATH/pkg/mod下，可以使用go clean -modcache 清理所有Module缓存 ","date":"2020/12/21","objectID":"/go-mod/:2:0","tags":[],"title":"Go mod原理一次讲透","uri":"/go-mod/"},{"categories":["Go系列"],"content":"3.各个工具主要特点对比 通常，一个好用的包管理工具应该具备下面几项能力 依赖管理 依赖包版本控制 包管理平台 私有化部署 代码包复用 支持代理（众所周知的原因） 工具 依赖管理 依赖包版本控制 包管理平台 私有化部署 代码包复用 支持代理 gopath Y N N N N N govendor Y Y N N N N godep Y Y N N N N go mod Y Y Y Y Y Y ","date":"2020/12/21","objectID":"/go-mod/:3:0","tags":[],"title":"Go mod原理一次讲透","uri":"/go-mod/"},{"categories":["Go系列"],"content":"4.使用go mod ","date":"2020/12/21","objectID":"/go-mod/:4:0","tags":[],"title":"Go mod原理一次讲透","uri":"/go-mod/"},{"categories":["Go系列"],"content":"4.1.设置环境变量 要使用go mod，go版本必须在v1.11及以上；然后设置必要的环境变量（小知识：使用命令go help environment 可以查看go支持的所有环境变量及其用法） $ go env -w GO111MODULE=on $ go env -w GOPROXY=https://goproxy.cn,direct //使用七牛云的代理服务 $ go env -w GOPATH=/Users/longyongyu/Development/go/workspace go env -w 会把配置写到go env GOENV 所配置的文件中，在我的macOS系统是/Users/longyongyu/Library/Application Support/go/env 文件。 $ cat /Users/longyongyu/Library/Application\\ Support/go/env GO111MODULE=on GOPATH=/Users/longyongyu/Development/go/workspace GOPROXY=https://goproxy.cn,direct 设置GO111MODULE=on 表示启用go mod， 此时go get go build go run 等命令将被go mod接管，并在运行这些命令的时候自动维护go.mod go.sum 文件。 goproxy 用于设置依赖的代理服务。 ","date":"2020/12/21","objectID":"/go-mod/:4:1","tags":[],"title":"Go mod原理一次讲透","uri":"/go-mod/"},{"categories":["Go系列"],"content":"4.2.初始化项目 $ mkdir gomod $ cd gomod $ go mod init gomod go: creating new go.mod: module gomod $ cat go.mod module gomod go 1.14 ","date":"2020/12/21","objectID":"/go-mod/:4:2","tags":[],"title":"Go mod原理一次讲透","uri":"/go-mod/"},{"categories":["Go系列"],"content":"4.3.增加依赖 我们使用go get 命令为新项目添加依赖gin: $ go get github.com/gin-gonic/gin go: github.com/gin-gonic/gin upgrade =\u003e v1.6.3 $ cat go.mod module gomod go 1.14 require github.com/gin-gonic/gin v1.6.3 我们发现新加了一行require github.com/gin-gonic/gin v1.6.3 ，其中v1.6.3 表示gin的版本，go get 拉取依赖的原则是： 若指定了版本，则拉取指定版本代码； 若未指定版本，则拉取最新的release tag. 若无tag, 则拉取最新的commit. ","date":"2020/12/21","objectID":"/go-mod/:4:3","tags":[],"title":"Go mod原理一次讲透","uri":"/go-mod/"},{"categories":["Go系列"],"content":"4.4.升级依赖 go get 升级依赖的方法： go get -u xxx 将升级到最新次要版本，或者修订版本（x.y.z中，x为主版本，y为次要版本，z为修订版本） go get -u=patch xxx 将升级到最新的修订版本 go get xxx@version 将升级到指定的version go list -m -u all列出可以升级的package $ go list -m -u all gomod github.com/davecgh/go-spew v1.1.1 github.com/gin-contrib/sse v0.1.0 github.com/gin-gonic/gin v1.6.3 github.com/go-playground/assert/v2 v2.0.1 github.com/go-playground/locales v0.13.0 github.com/go-playground/universal-translator v0.17.0 github.com/go-playground/validator/v10 v10.2.0 [v10.4.1] github.com/golang/protobuf v1.3.3 [v1.4.3] github.com/google/gofuzz v1.0.0 [v1.2.0] github.com/json-iterator/go v1.1.9 [v1.1.10] github.com/leodido/go-urn v1.2.0 [v1.2.1] github.com/mattn/go-isatty v0.0.12 github.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421 [v0.0.0-20180306012644-bacd9c7ef1dd] github.com/modern-go/reflect2 v0.0.0-20180701023420-4b7aa43c6742 [v1.0.1] github.com/pmezard/go-difflib v1.0.0 ... go get -u xxx 升级指定package go get -u 升级所有package ","date":"2020/12/21","objectID":"/go-mod/:4:4","tags":[],"title":"Go mod原理一次讲透","uri":"/go-mod/"},{"categories":["Go系列"],"content":"4.5.go.mod文件的四个关键字 module 指定包的名字 require 指定具体依赖项 replace 替换依赖项 exclude 忽略依赖项 module名用于import ,可以是名字形式也可以是路径形式（例：github.com/golang/crypto）,这样可避免命名冲突。 replace 用于替换无法直接拉取的依赖（国内朋友深有体会），该语句可以将依赖包用github上的库（或者本地私有库）进行替换。如 replace ( golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a =\u003e github.com/golang/crypto v0.0.0-20190313024323-a1f597ede03a ) exclude用于忽略某些依赖的版本，比如有的依赖的版本有问题。 exclude github.com/SermoDigital/jose v0.9.1 查看一个完整的示例 module github.com/example/project require ( github.com/SermoDigital/jose v0.0.0-20180104203859-803625baeddc github.com/google/uuid v1.1.0 ) exclude github.com/SermoDigital/jose v0.9.1 replace github.com/google/uuid v1.1.0 =\u003e git.coolaj86.com/coolaj86/uuid.go v1.1.1 ","date":"2020/12/21","objectID":"/go-mod/:4:5","tags":[],"title":"Go mod原理一次讲透","uri":"/go-mod/"},{"categories":["Go系列"],"content":"4.6.创建全新的module推送至github并使用 这里我们演示如何创建和提交一个新的module, 然后做为本地项目的依赖项使用。 $ mkdir firstgomod $ cd firstgomod $ go mod init github.com/Longyy/firstgomod go: creating new go.mod: module github.com/Longyy/firstgomod $ touch util.go 我们在util.go 中实现两个方法，用来比较两个整数的大小 package firstgomod func Max(x, y int) bool { return x \u003e y } func Min(x, y int) bool { return x \u003c y } 看一下go.mod的内容 module github.com/Longyy/firstgomod go 1.14 继续在firstgomod目录下执行命令提交firstgomod 到github $ git init $ touch .gitignore $ echo '.idea/' \u003e\u003e .gitignore # 我IDE用的goland，.idea信息应该加入.gitignore $ touch README.md $ echo '# firstgomod' \u003e\u003e README.md $ git add . $ git commit -m 'my first go module' $ git remote add origin git@github.com:Longyy/firstgomod.git $ git branch -M main # github已推荐将主分支设置为main(而非master) # 先在远端先创建firstgomod项目...，然后将本地代码推送至远端 $ git push origin main 一个全新的module制作完成，下面我们回到gomod项目来使用它 $ cd gomod $ go get github.com/Longyy/firstgomod go: downloading github.com/Longyy/firstgomod v0.0.0-20201226041745-5ea883bf90c4 go: github.com/Longyy/firstgomod upgrade =\u003e v0.0.0-20201226041745-5ea883bf90c4 上面提到，在没有明确指定依赖版本的情况下，go mod会拉取最新release tag, 若没有tag, 则拉取最新的commit生成一个自定义的版本号，当前firgomod就是这种情况（v0.0.0-20201226041745-5ea883bf90c4），版本号分三段：“默认版本号-最新Commit提交时间-最新CommitID). 我们要尽量避免使用这样的依赖，因为它实际上并没有进行版本控制，依赖是不稳定的。 在gomod/main.go文件中使用 package main import ( `fmt` `github.com/Longyy/firstgomod` `github.com/gin-gonic/gin` ) func main() { // 使用firstgomod fmt.Println(\"max value is:\", firstgomod.Max(1 ,2)) r := gin.Default() r.GET(\"/test\", func(context *gin.Context) { context.JSON(200, gin.H{ \"msg\": \"ok\", }) }) _ = r.Run(\":8080\") } ","date":"2020/12/21","objectID":"/go-mod/:4:6","tags":[],"title":"Go mod原理一次讲透","uri":"/go-mod/"},{"categories":["Go系列"],"content":"4.7.为firstgomod添加版本控制 打新的Release Tag $ cd /path/to/firstgomod $ git tag v1.0.0 $ git push --tags Total 0 (delta 0), reused 0 (delta 0) To github.com:Longyy/firstgomod.git * [new tag] v1.0.0 -\u003e v1.0.0 更新依赖 $ go get -u github.com/Longyy/firstgomod go: github.com/Longyy/firstgomod upgrade =\u003e v1.0.0 go: downloading github.com/Longyy/firstgomod v1.0.0 查看go.mod module gomod go 1.14 require ( github.com/Longyy/firstgomod v1.0.0 github.com/gin-gonic/gin v1.6.3 ) 看到firstgomod已经更新到最新的Tag v1.0.0 当我们自己在维护module的时候要注意使用语义化版本控制规范，在打补丁(patch)或升级的时候要从具体Tag上切分支，而不是main(或master), 这样才利于保证版本的向后兼容性。 ","date":"2020/12/21","objectID":"/go-mod/:4:7","tags":[],"title":"Go mod原理一次讲透","uri":"/go-mod/"},{"categories":["Go系列"],"content":"4.8.给Module添加打patch 接着我们来给Module打补丁: 给函数添加注释 $ git checkout v1.0.0 $ git checkout -b feature-v1 在util.go中添加注释 package firstgomod //计算整数较大值 func Max(x, y int) bool { return x \u003e y } //计算整数较小值 func Min(x, y int) bool { return x \u003c y } 提交patch到github $ git commit -am 'add func comment' $ git push -u origin feature-v1 $ git tag v1.0.1 $ git push --tags 更新gomod依赖 $ go get -u github.com/Longyy/firstgomod go: github.com/Longyy/firstgomod upgrade =\u003e v1.0.1 go: downloading github.com/Longyy/firstgomod v1.0.1 看到依赖已经更新。 ","date":"2020/12/21","objectID":"/go-mod/:4:8","tags":[],"title":"Go mod原理一次讲透","uri":"/go-mod/"},{"categories":["Go系列"],"content":"4.9.给Module更新次要版本 更新次要版本不应该影响module的向后兼容性，我们给firstgomod添加新函数Avg： package firstgomod //计算整数较大值 func Max(x, y int) bool { return x \u003e y } //计算整数较小值 func Min(x, y int) bool { return x \u003c y } //计算平均值 func Avg(x, y float32) float32 { return (x + y) / 2 } 打tag并提交到github $ git commit -am 'add Avg func' $ git push $ git tag v1.1.1 $ git push --tags 使用最新版 $ go get -u github.com/Longyy/firstgomod go: github.com/Longyy/firstgomod upgrade =\u003e v1.1.1 go: downloading github.com/Longyy/firstgomod v1.1.1 ","date":"2020/12/21","objectID":"/go-mod/:4:9","tags":[],"title":"Go mod原理一次讲透","uri":"/go-mod/"},{"categories":["Go系列"],"content":"4.10.给Module更新主版本 主版本更新可以不保证向后兼容性(同一项目的不同主版本可以认为是各自相互独立的项目)，这里我们给三个函数重命名来达到目的 package firstgomod/v2 //计算整数较大值 func IsMax(x, y int) bool { return x \u003e y } //计算整数较小值 func IsMin(x, y int) bool { return x \u003c y } //计算平均值 func GetAvg(x, y float32) float32 { return (x + y) / 2 } 同时为表示区分，我们将firstgomod的的module名字改为github.com/Longyy/firstgomod/v2 module github.com/Longyy/firstgomod/v2 go 1.14 打主版本Tag $ git commit -am 'add v2' $ git push $ git tag v2.0.0 $ git push --tags 在gomod项目中使用新的主版本v2.0.0 $ go get -u github.com/Longyy/firstgomod 这里发现依赖并没有更新，原因就是go get -u 不会去更新依赖的主版本号，必须要手动指定 $ go get github.com/Longyy/firstgomod@v2.0.0 go get github.com/Longyy/firstgomod@v2.0.0: github.com/Longyy/firstgomod@v2.0.0: invalid version: module contains a go.mod file, so major version must be compatible: should be v0 or v1, not v2 这时依赖还是不能更新，错误信息告诉我们在现有go.mod依赖下，主版本号必须是v0 或 v1。 我们需要在项目中import这个新版本的依赖，并且在代码中使用 import ( `fmt` `github.com/Longyy/firstgomod/v2` `github.com/gin-gonic/gin` ) func main() { // 使用firstgomod fmt.Println(\"avg value is:\", firstgomod.GetAvg(1 ,2)) r := gin.Default() r.GET(\"/test\", func(context *gin.Context) { context.JSON(200, gin.H{ \"msg\": \"ok\", }) }) _ = r.Run(\":8080\") } 然后运行go mod tidy ,可以看见新的版本被拉下来了 go 1.14 require ( github.com/Longyy/firstgomod/v2 v2.0.0 github.com/gin-gonic/gin v1.6.3 github.com/go-playground/validator/v10 v10.4.1 // indirect github.com/golang/protobuf v1.4.3 // indirect github.com/json-iterator/go v1.1.10 // indirect github.com/leodido/go-urn v1.2.1 // indirect github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect github.com/modern-go/reflect2 v1.0.1 // indirect github.com/ugorji/go v1.2.2 // indirect golang.org/x/crypto v0.0.0-20201221181555-eec23a3978ad // indirect golang.org/x/sys v0.0.0-20201231184435-2d18734c6014 // indirect google.golang.org/protobuf v1.25.0 // indirect gopkg.in/yaml.v2 v2.4.0 // indirect 当然，一个项目的新老版本是可以同时使用的，只要在import时使用别名就好了 package main import ( `fmt` `github.com/Longyy/firstgomod` firstgomodv2 `github.com/Longyy/firstgomod/v2` `github.com/gin-gonic/gin` ) func main() { // 使用firstgomod fmt.Println(\"avg value is:\", firstgomodv2.GetAvg(1 ,2)) fmt.Println(\"Avg value is:\", firstgomod.Avg(1 ,2)) // ... } ","date":"2020/12/21","objectID":"/go-mod/:4:10","tags":[],"title":"Go mod原理一次讲透","uri":"/go-mod/"},{"categories":["Go系列"],"content":"5.go mod如何保证项目依赖的稳定性 go.mod文件记录项目所有依赖项目及其版本信息，可有没有想过，我们依赖的这些库如果被篡改了怎么办？或者依赖库的作者删除了我们正在依赖的某些版本怎么办？ 实际上, go mod使用了分布式的依赖检验方式，没有统一的依赖镜像中心，每一个项目都维护一份本地的依赖信息，是不是有点“区块链”的味道~ ","date":"2020/12/21","objectID":"/go-mod/:5:0","tags":[],"title":"Go mod原理一次讲透","uri":"/go-mod/"},{"categories":["Go系列"],"content":"5.1.go.sum 这里go mod引入了go.sum文件协同go.mod文件进行依赖管理。 go.sum的作用类似于“借条”，里边详细记录了每一笔“借款”帐目：向谁借的，借的什么，落款签名。其结构如下： \u003cmodule\u003e \u003cversion\u003e[/go.mod] \u003chash\u003e 每行记录由module名、版本、哈希值组成。这里分两种情况： 如果所依赖的版本使用了go mod, 则module名就是go.mod中的module字段 如果没有使用go mod, 则module名就是项目路径 比如： //使用了go mod github.com/go-playground/validator/v10 v10.4.1 h1:pH2c5ADXtd66mxoE0Zm9SUhxE20r7aM3F26W0hOn+GE= //未使用go mod github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd h1:TRLaZ9cD/w8PVh93nsPXa1VrQ6jlwL5oN8l14QlcNfg= 同时，还会为每个依赖版本库生成一行go.mod文件的检验值 github.com/gin-gonic/gin v1.6.3/go.mod h1:75u5sXoLsGZoRN5Sgbi1eraJ4GU3++wFwWzhwvtwp4M= 这个值主要是用在生成依赖树的时候，不必将所有的依赖库代码都拉下来，只用go.mod就行了。 如何生成依赖树呢，使用go mod why xxx(module name) 命令即可： $ go mod why github.com/go-playground/validator/v10 # github.com/go-playground/validator/v10 gomod github.com/gin-gonic/gin github.com/gin-gonic/gin/binding github.com/go-playground/validator/v10 Hash值前面都会跟一个\"h1:“的前缀，表示使用的是hash算法的版本，目前只使用了一种hash算法：SHA-256. go.mod只记录直接依赖与间接依赖（当依赖没有使用go mod时），go.sum会记录下每一笔版本信息. 当我们执行go get xxx命令时, go mod会将依赖下载到$GOPATH/pkg/mod/cache/download 指示的路径下，并生成v.x.y.x.zip的压缩包，同时生成该压缩包的hash值放入v.x.y.x.ziphash文件中，如果执行go get时目录中有go.mod文件，则在生成好hash值后，会同步更新go.mod和go.sum文件，将版本信息及hash值写入。 同时，为保证hash值真实可靠，go mod会向环境变量GOSUMDB指示的服务发起请求，检验该hash是否真实可靠。 ","date":"2020/12/21","objectID":"/go-mod/:5:1","tags":[],"title":"Go mod原理一次讲透","uri":"/go-mod/"},{"categories":["Go系列"],"content":"5.2.GOSUMDB 我们可以通过设置环境变量GOSUMDB指示一个校验数据库服务，提供查询依赖包版本哈希值 的服务，此时go get在拉取每一个依赖时，都会去查询该依赖的检验和是否合法，如果不合法go get 将中止执行。 GOSUMDB=off即关闭此服务，go get将跳开校验，相信所有依赖库。 Google官方的sum.golang.org记录了所有的可公开获得的依赖包版本。除了使用官方的数据库，还可以指定自行搭建的数据库。 ","date":"2020/12/21","objectID":"/go-mod/:5:2","tags":[],"title":"Go mod原理一次讲透","uri":"/go-mod/"},{"categories":["Go系列"],"content":"6.总结 本文用较长的篇幅详细说明了go mod的前世今生，以及在使用中应该注意处理的细节、常用操作的罗列，希望大家在通读后能对go的依赖包管理机制有所了解，并在工作做到心中有数、灵活运用。 欢迎留言交流，谢谢。 ","date":"2020/12/21","objectID":"/go-mod/:6:0","tags":[],"title":"Go mod原理一次讲透","uri":"/go-mod/"},{"categories":["Kubernetes系列"],"content":"我们知道Docker使用Namespace对容器进程进行隔离，让容器进程只能看到该Namespce内的“世界”；同时使用Cgroups来限制容器资源，那容器内的文件系统呢，难到要继承宿主机的文件系统吗？显然不是，不然宿主机上多个容器之间岂不乱套了。实际上，Docker使用了Mount Namespace和RootFS技术，对文件系统进行了隔离, 使得容器可以拥有完全独立的文件系统。 ","date":"2020/12/6","objectID":"/rootfs/:0:0","tags":[],"title":"容器镜像之RootFS解析","uri":"/rootfs/"},{"categories":["Kubernetes系列"],"content":"Mount Namespace 为了理解其原理，我使用某大V的一段C程序： #define _GNU_SOURCE #include \u003csys/mount.h\u003e #include \u003csys/types.h\u003e #include \u003csys/wait.h\u003e #include \u003cstdio.h\u003e #include \u003csched.h\u003e #include \u003csignal.h\u003e #include \u003cunistd.h\u003e #define STACK_SIZE (1024 * 1024) static char container_stack[STACK_SIZE]; char* const container_args[] = { \"/bin/bash\", NULL }; int container_main(void* arg) { printf(\"Container - inside the container!\\n\"); execv(container_args[0], container_args); printf(\"Something's wrong!\\n\"); return 1; } int main() { printf(\"Parent - start a container!\\n\"); int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWNS | SIGCHLD , NULL); waitpid(container_pid, NULL, 0); printf(\"Parent - container stopped!\\n\"); return 0; } 该程序通过clone创建一个子进程并声明启用Mount Namespace (CLONE_NEWNS), 子进程创建后执行”/bin/bash\"命令，这个shell运行在Mount Namespace的隔离环境中。我们来编译并执行这个程序： $ gcc -o ns ns.c $ ./ns Parent - start a container! Container - inside the container! 于是，我们进入了“容器”当中，我们接着看一下/tmp目录下的内容： $ ls /tmp # 会看到内容与宿主机上/tmp目录的一模一样 新创建的容器会直接继承宿主机上的各个挂载点。并没有起到我们想要的“隔离”的作用。 事实上，要让Mount Namespace起作用，除了在创建容器时进行声明，我们还要告诉容器哪些目录要进行挂载。这里我们修改代码重新挂载/tmp目录： // ... int container_main(void* arg) { printf(\"Container - inside the container!\\n\"); mount(\"none\", \"/tmp\", \"tmpfs\", 0, \"\"); //重新以tmpfs(内存盘)的格式挂载/tmp目录 execv(container_args[0], container_args); printf(\"Something's wrong!\\n\"); return 1; } // ... 修改后再次编译执行， $ gcc -o ns ns.c $ ./ns Parent - start a container! Container - inside the container! $ ls /tmp 发现此时tmp变成了空目录。可以用“df -a”命令查看一下。 $ df -a | grep tmp # none 512920 0 512920 0% /tmp 我们在宿主机上再次查看： $ df -a | grep tmp # none 512920 0 512920 0% /tmp 这是因为很多云服务器上根目录的挂载是shared类型的，可以如下进行查看： $ cat /proc/self/mountinfo 22 1 253:1 / / rw,relatime shared:1 - ext4 /dev/vda1 rw,errors=remount-ro,data=ordered 为避免这种情况，我们需要在容器中对根目录进行重新挂载： // ... int container_main(void* arg) { printf(\"Container - inside the container!\\n\"); //根目录的挂载类型是shared，需要重新挂载根目录 //mount(\"\", \"/\", NULL, MS_PRIVATE, \"\"); mount(\"none\", \"/tmp\", \"tmpfs\", 0, \"\"); //重新以tmpfs(内存盘)的格式挂载/tmp目录 execv(container_args[0], container_args); printf(\"Something's wrong!\\n\"); return 1; } // ... 再次编译执行，发现宿主机中没有/tmp的挂载信息了。 Mount Namespce与其他Namespace不同的地方，它对容器进程视图的改变，一定是有挂载操作（mount）之后才能生效。 ","date":"2020/12/6","objectID":"/rootfs/:1:0","tags":[],"title":"容器镜像之RootFS解析","uri":"/rootfs/"},{"categories":["Kubernetes系列"],"content":"chroot 当创建容器后我们希望在容器里边看到的文件系统是一个独立的隔离环境。 有了Mount Namespace, 我们可以在容器进程开始前挂载根目录/, 这个挂载对宿主机是不可见的。 Linux系统中有命令chroot: change root file system, 可以方便实现这一目的。 我们一起来操作一下： # 创建目录 $ mkdir -p $HOME/test $ mkdir -p $HOME/test/{lib,lib64,bin} $ mkdir -p $HOME/test/lib/i386-linux-gnu # 拷贝命令 $ cp -v /bin/{bash,ls} $HOME/test/bin # 拷贝bash,ls命令所需要的所有.so文件 $ T=$HOME/test $ list=\"$(ldd /bin/ls | egrep -o '/lib.*\\.[0-9]')\" $ for i in list; do cp -v \"$i\" \"${T}${i}\"; done $ list2=\"$(ldd /bin/bash | egrep -o '/lib.*\\.[0-9]')\" $ for i in list2; do co -v \"$i\" \"${T}${i}\"; done 最后执行chroot命令，我们将使用$HOME/test目录作为/bin/bash的根目录： $ chroot $HOME/test /bin/bash bash-4.3# ls / bin lib lib64 对于被chroot的进程它们并不知道自己的根目录已经被“修改”了。 为了让根目录更真实，我们通常会在根目录下挂载一个完整的操作系统的文件系统，比如Ubuntu16.04的ISO。 这个挂载在容器根目录上，用来给容器提供隔离后执行环境的文件系统，就是“容器镜像”，也叫：rootfs（根文件系统）. ","date":"2020/12/6","objectID":"/rootfs/:2:0","tags":[],"title":"容器镜像之RootFS解析","uri":"/rootfs/"},{"categories":["Kubernetes系列"],"content":"Docker提供pull/run命令来拉取镜像和运行容器，可你知道镜像被拉取下来后是如何存放的吗，一个镜像就是一个文件？如果你知道镜像的存储格式或者对RootFS有所了解，那么你显然会说：No. 下面我们来一步一步看看究竟是怎么一回事。 演示环境：ubuntu 16.04 / docker 20.10.0 ","date":"2020/12/6","objectID":"/docker-image-container-storage-drivers/:0:0","tags":["overlay2"],"title":"理解Docker中镜像与容器的存储引擎","uri":"/docker-image-container-storage-drivers/"},{"categories":["Kubernetes系列"],"content":"一、获取docker存储关键信息 执行 $ docker info ... Storage Driver: overlay2 Backing Filesystem: extfs Docker Root Dir: /var/lib/docker ... 在输出信息中找到Storage Driver、Docker Root Dir、Backing Filesystem三个配置项，合起来的意思是说，docker的存储路径是/var/lib/docker，该路径下的文件格式为extfs，使用的存储引擎是overlay2. 不同操作系统中Docker存储路径有所不同： Ubuntu: /var/lib/docker/ Fedora: /var/lib/docker/ Debian: /var/lib/docker/ Windows: C:\\ProgramData\\DockerDesktop MacOS: ~/Library/Containers/com.docker.docker/Data/vms/0/ Docker Engine - Community (社区版)， 在Linux的不同发行版上推荐的存储引擎如下表： Linux distribution Recommended storage drivers Alternative drivers Docker Engine - Community on Ubuntu overlay2 or aufs (for Ubuntu 14.04 running on kernel 3.13) overlay¹, devicemapper², zfs, vfs Docker Engine - Community on Debian overlay2 (Debian Stretch), aufs or devicemapper (older versions) overlay¹, vfs Docker Engine - Community on CentOS overlay2 overlay¹, devicemapper², zfs, vfs Docker Engine - Community on Fedora overlay2 overlay¹, devicemapper², zfs, vfs ¹) The overlay 引擎已被废弃，推荐使用 overlay2. ²) The devicemapper 引擎已被废弃，推荐使用 overlay2. OverlayFS是一种堆叠文件系统（联合文件系统），它依赖并建立在其它的文件系统之上（例如ext4fs和xfs等等），并不直接参与磁盘空间结构的划分，仅仅将原来底层文件系统中不同的目录进行“合并”，然后向用户呈现。因此对于用户来说，它所见到的overlay文件系统根目录下的内容就来自挂载时所指定的不同目录的“合集”。 Docker为OverlayFS提供了两个存储引擎，原始的Overlay和更稳定的Overlay2. 当前安装Docker时，overlay2已经是默认的存储引擎了, 在此之前aufs是默认引擎，点此获取关于aufs的更多信息 Backing Filesystem与存储引擎的对应关系： Storage driver Supported backing filesystems overlay2, overlay xfs with ftype=1, ext4 fuse-overlayfs any filesystem aufs xfs, ext4 devicemapper direct-lvm btrfs btrfs zfs zfs vfs any filesystem ","date":"2020/12/6","objectID":"/docker-image-container-storage-drivers/:1:0","tags":["overlay2"],"title":"理解Docker中镜像与容器的存储引擎","uri":"/docker-image-container-storage-drivers/"},{"categories":["Kubernetes系列"],"content":"二、理解overlay2存储引擎 OverlayFS在单个Linux主机上将两个目录合并成一个目录，这些目录叫做Layers（层），这个过程叫做Union mount（联合挂载）,将较低的目录叫做lowerdir, 较高的目录叫做upperdir,合并后的目录通过merged目录暴露。 OverlayFS原生支持128层的lowerdir,将提升docker build docker commit的性能，并在主机文件系统上消耗更少的inode. 我们首先拉取示例镜像docker pull ubuntu,该镜像包含三个层，在/var/lib/docker/overlay2目录下可见4个文件。 $ ls -l /var/lib/docker/overlay2 total 16 drwx------ 4 root root 4096 Dec 14 18:48 6bcbe401bf9563cef765537d56d6b41614916fea9c9a4a04da7740df22be2b0a drwx------ 3 root root 4096 Dec 14 18:48 ec043c375f562d2450b6ec600df751d3c175d45928d65bbec06f29de2021c022 drwx------ 4 root root 4096 Dec 14 18:48 fdb1a5544aa14447881a4168a34715387a4e1eb2d4bead7111987cc8eb779498 drwx------ 2 root root 4096 Dec 14 18:48 l l目录下以符号链接的方式重新组织了层信息，避免mount参数超限。 $ ls -l /var/lib/docker/overlay2/l total 12 lrwxrwxrwx 1 root root 72 Dec 14 18:48 4BXWJGCYLNYIKGVSNAC2FTDV7C -\u003e ../fdb1a5544aa14447881a4168a34715387a4e1eb2d4bead7111987cc8eb779498/diff lrwxrwxrwx 1 root root 72 Dec 14 18:48 HS3PTDGILSMO7PRIHEHCPO2FGU -\u003e ../ec043c375f562d2450b6ec600df751d3c175d45928d65bbec06f29de2021c022/diff lrwxrwxrwx 1 root root 72 Dec 14 18:48 U6CEQQLZFHHVL62ROBOALZJUSR -\u003e ../6bcbe401bf9563cef765537d56d6b41614916fea9c9a4a04da7740df22be2b0a/diff 最底层包含一个文件link和一个目录diff, link文件里存放了符号链接的标识符，diff目录下存放层内容。 $ cat /var/lib/docker/overlay2/ec043c375f562d2450b6ec600df751d3c175d45928d65bbec06f29de2021c022/link HS3PTDGILSMO7PRIHEHCPO2FGU $ ls /var/lib/docker/overlay2/ec043c375f562d2450b6ec600df751d3c175d45928d65bbec06f29de2021c022/diff bin boot dev etc home lib lib32 lib64 libx32 media mnt opt proc root run sbin srv sys tmp usr var 倒数第二层及上面各层均含有lower文件，存放着联合挂载信息；diff目录包含有该层文件内容；merge目录包含该层与父级目录合并后的文件内容。work目录是OverlayFS内置的。 $ tree -L 2 /var/lib/docker/overlay2/ /var/lib/docker/overlay2/ ├── 6bcbe401bf9563cef765537d56d6b41614916fea9c9a4a04da7740df22be2b0a │ ├── diff │ ├── link │ ├── lower │ └── work ├── ec043c375f562d2450b6ec600df751d3c175d45928d65bbec06f29de2021c022 │ ├── committed │ ├── diff │ └── link ├── fdb1a5544aa14447881a4168a34715387a4e1eb2d4bead7111987cc8eb779498 │ ├── committed │ ├── diff │ ├── link │ ├── lower │ └── work └── l ├── 4BXWJGCYLNYIKGVSNAC2FTDV7C -\u003e ../fdb1a5544aa14447881a4168a34715387a4e1eb2d4bead7111987cc8eb779498/diff ├── HS3PTDGILSMO7PRIHEHCPO2FGU -\u003e ../ec043c375f562d2450b6ec600df751d3c175d45928d65bbec06f29de2021c022/diff └── U6CEQQLZFHHVL62ROBOALZJUSR -\u003e ../6bcbe401bf9563cef765537d56d6b41614916fea9c9a4a04da7740df22be2b0a/diff $ cat /var/lib/docker/overlay2/fdb1a5544aa14447881a4168a34715387a4e1eb2d4bead7111987cc8eb779498/lower l/HS3PTDGILSMO7PRIHEHCPO2FGU $ ls /var/lib/docker/overlay2/fdb1a5544aa14447881a4168a34715387a4e1eb2d4bead7111987cc8eb779498/diff etc usr var 当容器启动后，Docker会使用Overlay2引擎挂载容器目录。我们运行docker run命令看一下实际效果 $ docker run -d ubuntu:latest sleep 3600 566450ecf2684dc2a033beb49b34cce92d003674ec5a8d606810d2b68fa489de $ mount | grep overlay2 overlay on /var/lib/docker/overlay2/fea4e43477579fa2e2f5a4b287592e9319a8c17c5e3d659199ba56b02f580ef9/merged type overlay (rw,relatime, lowerdir=/var/lib/docker/overlay2/l/H3E7H2MFUWPVV3NLOJBVDFJED3:/var/lib/docker/overlay2/l/J3EFNT6RSZDLTHG524LM42JLJT:/var/lib/docker/overlay2/l/TDFRV2Z66UAACTA3KP5KLQLADK:/var/lib/docker/overlay2/l/ALV2R4IDYWACLQRARWKANDDPW7, upperdir=/var/lib/docker/overlay2/fea4e43477579fa2e2f5a4b287592e9319a8c17c5e3d659199ba56b02f580ef9/diff, workdir=/var/lib/docker/overlay2/fea4e43477579fa2e2f5a4b287592e9319a8c17c5e3d659199ba56b02f580ef9/work) 第二行中rw表示该挂载目录可读可写。 /var/lib/docker/overlay2/fea4e43477579fa2e2f5a4b287592e9319a8c17c5e3d659199ba56b02f580ef9/merged目录即是联合挂载后的视图，也就是在容器中看到的文件结构。容器有多个lowerdir（只读层），只有一个upperdir（可读写层），当在容器中真正更新 创建 删除 文件时，内容都保存在upperdir 目录中。 ","date":"2020/12/6","objectID":"/docker-image-container-storage-drivers/:2:0","tags":["overlay2"],"title":"理解Docker中镜像与容器的存储引擎","uri":"/docker-image-container-storage-drivers/"},{"categories":["Kubernetes系列"],"content":"三、Container对Overlay2上文件的读写 下图是docker存储结构与OverlayFS存储结构的映射关系 ","date":"2020/12/6","objectID":"/docker-image-container-storage-drivers/:3:0","tags":["overlay2"],"title":"理解Docker中镜像与容器的存储引擎","uri":"/docker-image-container-storage-drivers/"},{"categories":["Kubernetes系列"],"content":"1.Read 文件在Container layer不存在，则从Image layer读取；（file1） 文件在Container layer存在，则直接从Container layer读取（file2, file4） ","date":"2020/12/6","objectID":"/docker-image-container-storage-drivers/:3:1","tags":["overlay2"],"title":"理解Docker中镜像与容器的存储引擎","uri":"/docker-image-container-storage-drivers/"},{"categories":["Kubernetes系列"],"content":"2.Write 第一次写入一个文件。如果文件已存在，但并不存在于Container layer中，则overlay会进行一次copy_up操作，先将文件内容从Image layer(lowerdir)拷贝到Container layer(upperdir)中，然后对Container layer上的文件进行写入操作。 OverlayFS是工作在文件级别的，而不是块级别的，因此copy_up操作会将整个文件进行一次拷贝，即使这个文件非常大而我们只修改一个小地方。因此container的第一次写性能还是有一定损耗的。 其他时间写入文件。则直接操作Container layer中对应文件。 删除文件和目录。当删除文件时，Container layer中建立一个whiteout文件，而Image layer中该文件不会被删除，因为是Read-Only的。Whiteout文件会阻止对此文件的访问。 当我们删除目录时，会建立一个opaque目录。 ","date":"2020/12/6","objectID":"/docker-image-container-storage-drivers/:3:2","tags":["overlay2"],"title":"理解Docker中镜像与容器的存储引擎","uri":"/docker-image-container-storage-drivers/"},{"categories":["Kubernetes系列"],"content":"四、总结 我们可以把层看作是有文件的目录，多个目录间有至上而下的依赖关系，然后通过联合挂载的文式合并成一个视图（目录），再将这个合并后的目录以RootFS方式挂载到docker容器进程中去。 我们的写操作都在Container layer层上进行，不会影响镜像层。另外，我们在容器里边删除Image layer中文件，并不是真正的删除，而是建立一个whiteout文件（套用大V的话来说就叫：白障）来阻止对相应文件的访问。 ","date":"2020/12/6","objectID":"/docker-image-container-storage-drivers/:4:0","tags":["overlay2"],"title":"理解Docker中镜像与容器的存储引擎","uri":"/docker-image-container-storage-drivers/"},{"categories":[],"content":"破折号介绍","date":"2020/6/29","objectID":"/about/","tags":[],"title":"关于破折号","uri":"/about/"},{"categories":[],"content":"#关于破折号 ","date":"2020/6/29","objectID":"/about/:0:0","tags":[],"title":"关于破折号","uri":"/about/"},{"categories":["算法系列"],"content":"冒泡排序算法介绍","date":"2020/6/29","objectID":"/algorithm-bubble-sort/","tags":["排序算法"],"title":"冒泡排序算法","uri":"/algorithm-bubble-sort/"},{"categories":["算法系列"],"content":"#冒泡排序算法 package main import \"fmt\" //冒泡排序 func BubbleSort(a []int32, n int32) { //循环每一轮后，有序序列长度加一 for i := int32(0); i \u003c n; i++ { //记录每一轮是否有数据交换 flag := false //从头遍历数据至 n - i - 1 位置， 因为后 i 个数\"已经有序\"， 且因为是与后序数据比较，所以最后一个数不必遍历，-1 for j := int32(0); j \u003c n - i - 1; j++ { //默认正序排序，当前一个数 大于 后一个数时，交换位置 if a[j] \u003e a[j+1] { temp := a[j+1] a[j+1] = a[j] a[j] = temp flag = true } } //如果本轮没有数据交换，则已全部有序 if !flag { break } } fmt.Println(a) } func main() { test := []int32{3,2,4,5,1,7,4,2, 8,0} BubbleSort(test, 10) } ","date":"2020/6/29","objectID":"/algorithm-bubble-sort/:0:0","tags":["排序算法"],"title":"冒泡排序算法","uri":"/algorithm-bubble-sort/"},{"categories":["算法系列"],"content":"插入排序算法介绍","date":"2020/6/29","objectID":"/algorithm-insertion-sort/","tags":["排序算法"],"title":"插入排序算法","uri":"/algorithm-insertion-sort/"},{"categories":["算法系列"],"content":"插入排序算法 package main import \"fmt\" //插入排序（Insertion Sort） func InsertionSort(a []int, n int) { //数组个数为1，已经有序 if n == 1 { return } //从第二个元素开始遍历后面每一个元素，寻找插入点 for i := 1; i \u003c n; i++ { value := a[i] //j标识了有序数组的末尾边界 j := i - 1 //从后往前遍历有序数组中的元素 for ; j \u003e= 0; j-- { //将不满足插入点位的元素后移 if a[j] \u003e value { a[j+1] = a[j] } else { //如果初始时，待插入元素大于等于有序数组中最大的元素，则插入点位已确定 break } } //将待插入元素放入插入点位 a[j+1] = value } } func main() { test := []int{3,5,2,6,1,8} InsertionSort(test, 6) fmt.Println(test) } #输出 [1 2 3 5 6 8 ","date":"2020/6/29","objectID":"/algorithm-insertion-sort/:0:0","tags":["排序算法"],"title":"插入排序算法","uri":"/algorithm-insertion-sort/"}]